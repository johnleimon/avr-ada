//
// gen-offsets
//
// Copyright 2000, 2001, 2002, 2003, 2004 Dean Ferreyra
//
// $Id: gen-offsets.c,v 1.3 2008-09-04 01:10:01 dean Exp $
// Dean Ferreyra

/*
This file is part of AVR-THREADS.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 59 Temple Place, Suite
330, Boston, MA 02111-1307  USA

Contact information:

Dean Ferreyra
12902 Malena Drive
Santa Ana, CA 92705-1102  USA

dean@octw.com
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/signal.h>
#include <uart.h>
#define DEBUG_STACK_USAGE 1
#include <avr-thread.h>
#include <stddef.h>
#include <inttypes.h>

void tx_char(char c)
{
    while (! uart_tx_char(c))
        ;
}

void tx_str(const char* str)
{
    for (;;) {
        tx_char(*str);
        if (! *++str)
            break;
    }
}

void tx_number(uint16_t size)
{
    if (size >= 100) {
        tx_char('0' + size / 100);
        size -= (size / 100) * 100;
    }
    if (size >= 10) {
        tx_char('0' + size / 10);
        size -= (size / 10) * 10;
    }
    tx_char('0' + size);
}

void tx_offset(const char* name, int offset)
{
    tx_str("#define CONTEXT_");
    tx_str(name);
    tx_char(' ');
    tx_number(offset);
    tx_char('\r');
    tx_char('\n');
}

int main(void)
{
    // Initialize the UART interrupt stuff.
    // 4 MHz - 9600: 25
    // 3.68 MHz - 9600: 22
    UBRR = 22;
    uart_tx_init();

    sei();

    tx_str("// File generated by gen-offsets\r\n\r\n");
    tx_offset("STATE", offsetof(avr_thread_context, state));
    tx_offset("STACK_PTR", offsetof(avr_thread_context, stack_ptr));
    tx_offset("NEXT", offsetof(avr_thread_context, next));
    tx_offset("TIMEOUT", offsetof(avr_thread_context, timeout));
    tx_offset("WAITING_FOR", offsetof(avr_thread_context, waiting_for));
    tx_offset("NEXT_WAITING", offsetof(avr_thread_context, next_waiting));
    tx_offset("PREV_WAITING", offsetof(avr_thread_context, prev_waiting));

    tx_offset("STACK_END", offsetof(avr_thread_context, stack_end));
    tx_offset("MIN_STACK_PTR", offsetof(avr_thread_context, min_stack_ptr));
    return 0;
}
